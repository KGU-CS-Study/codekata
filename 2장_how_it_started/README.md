코드 카타 : 어떻게 시작할까

이것은 길다. 이것은 내가 코딩을 향상시키기 위해 거의 매일하는 일이 실제로 무술연습과 공통점이 있는 작은 점이라는 것을 발견한것을 설명한다.
이것은 RubLog 로 부터 시작되어진다. 나는 그것이 어떻게 검색되어 지는지 실험하고 싶었다.
(그러나 이거는 검색에 대한 기사나 칼럼이 아니니 나를 믿어라)

나는 코사인 기반의 비교를 사용하여 비슷한 기사를 찾고 싶었서, 나는 벡터 단어 맵핑 발생을 도큐먼트 블로그로 만들었다.

기본적으로 각 문서에 대해 1200 ~ 1500 비트를 설정하였다.
서치의 기본 랭킹을 향상시키기 위해 나는 조건에 포함된 벡터와 벡터 각각의 비트 단위 AND 를 수행한 다음 결과에서 1 비트수를 계산할 수 있어야 했다.

나는 지난밤에 45분을 보냈다. (나는 Zachary 의 카라테 레슨을 보았다 그러나 그 방에는 부모님이 지켜보는 방이 업었다.)
그래서 나는 생각했다 이것을 가지고 놀면 되겠따고

첫번째로 나는 비트벡터를 다른 방법으로 쌓는것을 시도했다.
내가 발견한것은 (놀랍게도) fixnums 의 쌓는 방법의 속도가 bignum 의 속도와 거의 비슷하다는 것이다.

왜냐하면 그것은 더 정밀하게 정리하기 떄문에 나는 bignum 을 결정하였습니다.

그 다음 나는 비트 카운팅 이것 스스로 더 재미있게 놀았다. 기존 의 명백한 코드를 사용하면서.

```java
max_bit.times { |i| count += word[i] }
```

이게 얼마나 느린거야? 저는 각각 1,000 개의 비트 벡터를 생성하는 간단한 테스트 베드를 작성했습니다. 각각의 비트 벡터는 20 개의 랜덤 비트 세트로 구성되어 있으며 루프를 타임 아웃했습니다. 100 명 모두에게 약 0.4 초가 걸렸습니다.

그런 다음 Hacker 's Delight 5 장의 'divide-and-conquer'계산 알고리즘을 사용하여 시도했습니다 (Bignum을 30 비트 단어로 청크 처리하도록 수정 됨).

```java
((max_bit+29)/30).times do |offset|
  x = (word >> (offset*30)) & 0x3fffffff
  x = x - ((x >> 1) & 0x55555555)
  x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
  x = (x + (x >> 4)) & 0x0f0f0f0f;
  x = x + (x >> 8)
  x = x + (x >> 16)
  count += x & 0x3f
end
```
이것은 순진 알고리즘보다 약 2.5 배 빠릅니다.

그런 다음 검색 시간을 단어 몇 개와 비교할 때 비트 벡터가 매우 희박하다는 것을 알았습니다. 위 루프의 각 청크는 0 일 가능성이 높습니다. 그래서 나는 테스트를 추가했다 :

```java
(max_bit+29)/30).times do |offset|
  x = (word >> (offset*30)) & 0x3fffffff
  next if x.zero?
  x = x - ((x >> 1) & 0x55555555)
  x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
  x = (x + (x >> 4)) & 0x0f0f0f0f;
  x = x + (x >> 8)
  x = x + (x >> 16)
  count += x & 0x3f
end
```

이제는 원래보다 7 배 빠릅니다. 그러나 테스트 베드는 20 비트 (1,000 개 중)를 포함하는 벡터를 사용하고있었습니다. 1, 2, 5, 10, 20, 100 및 900 세트 비트를 포함하는 벡터로 타이밍을 생성하도록 변경했습니다. 이것은 더 나아졌습니다 : 저는 벡터에서 1 또는 2 비트로 15 배 빨랐습니다.

그러나 비트 - 트 와이들 링 알고리즘에서 제로 청크를 제거하여 이처럼 많은 것을 빠르게 할 수 있다면 간단한 계산 알고리즘에서도 동일한 작업을 수행 할 수 있습니까? 나는 세 번째 알고리즘을 시도했다.

```java
((max_bit+29)/30).times do |offset|
   x = (word >> (offset*30)) # & 0x3fffffff
   next if x.zero?
   30.times {|i| count += x[i]}
 end
```

여기에있는 내부 루프는 원래 카운트와 동일하지만 이제는 30 비트로 계산됩니다.

이 코드는 1 세트 비트에 대해 비트 - 트 와이들 링 코드와 동일하게 수행되며 2 비트 세트에 대해서만 약간 나빠집니다. 하나. 일단 비트 수가 증가하기 시작하면 (주어진 청크 크기에 대해 5를 지나면) 성능이 떨어지게됩니다. 100 비트에서 원래의 순진 횟수보다 느립니다.

따라서 특정 응용 프로그램의 경우 청크 계산 알고리즘 중 하나를 선택했을 수 있습니다. 조금씩 움직이는 비트가 더 많은 비트로 확장되기 때문에 나중에 코사인 기반 문서 매칭을 시작하면 나중에 필요하기 때문에 함께 갈 것입니다.

- 그래서 여기에서 포인트는 무엇일까?!

어제 나는 동사의 중요성에 관한 블로그 글을 올렸다. "종종 물건의 진정한 가치는 그 자체가 아니라 창조 한 활동입니다."채드 파울러 (Chad Fowler)는 이것을 받아 들여 이것이 음악가들에게 어떻게 적용되는지 보여주는 멋진 작품을 썼습니다. 브라이언 마릭 (Brian Marick)은 창작 과정을 배울 때 연습의 가치를 강조하기 위해 차드 (Chad)의 작품을 골랐습니다.

동시에 Andy와 나는 그가 갖고있는 일련의 음악 테이프에 대해 토론하고있었습니다. 원래 뮤지션들이 스케일과 아르페지오를 연습 할 수 있도록 디자인 되었기 때문에 매우 인기가있어서 이제는 전체 스펙트럼의 연습 테크닉을 포함하고 있습니다. 우리는 개발자들이 프로그래밍을 수행하는 데 도움이되는 약간의 원조를 구입하는 것과 같은 것을 할 수는 없을 것 같았습니다. 우리는 단지 연습이 프로그래머가하는 것이 아니라고 생각했습니다.

오늘 아침으로 건너가서, 소나기 속에서 나는 이것에 대해서 생각했다. 그리고 나의 작은 45분의 비트 카운트의 대한 탐사가 정확하게 연습하는 시간이라는 것을.
나는 결코 블로그의 서치알고리즘의 비트 카운트의성능에 대해서 걱정하지 않았습니다.

실제로 금방 돌아옵니다. 대신에 나는 지금까지 사용하지 않았던 몇명 기술로 몇가지 코드와 실험을 하고 싶었습니다.
그것을 단순하고 통제된 환경에서 그리고 나느 다른 많은 변수들을 실행했습니다.

그리고 나는 여전히 더 해야할 것들이 있습니다. 나는 청크 크기를 변화시키는 효과를 가지고 혼란스러워하고 싶다. 그리고 나는 다른 비트 계산 알고리즘 중 어떤 것이 더 빨리 수행되는지보고 싶다.

무엇이 이것을 연습 세션으로 만들었습니까?  
글쎄, 나는 방해받지 않고 약간의 시간을 보냈다.   
시도하고 싶었던 간단한 일을 여러 번 시도했습니다.   
개선 할 수 있도록 매번 피드백을 찾았습니다.  
압력은 없었습니다. 코드는 효과적으로 폐기되었습니다. 즐거웠습니다   
: 나는 계속 앞으로 나아가는 작은 발걸음을 내디뎠다. 마침내, 내가 들어갔을 때보다 더 많이 알게되었습니다.  

궁극적으로 이것은 나에게 연습하는 것에 대한 자유시간을 주었습니다.  
만약 블로그 서치 기능에 대해서 데드라인과 압박이 잇었다면 그 기존의 성능 그대로 받아들여 졌을것입니다.
그러나 나에게 자유스러운 45분에 있어서 그것이 잇었습니다.

그래서 현실세계에서 어떻게 할 수 있을까?
개발자가 어떻게 창조적인 프로세스에서 분명히 필요한 연습을 도울 수 있을까?
나도 잘은 모르지만, 나는 내가 느낀 것들은 나에게 우리가 해야할 2가지를 말해주고 있다.

첫번째는 압박을 받으면 안된다는 것이다. 마감기한이 다가오지 않은 일시적인 오아시스 같은 환경을 제공해라.
이것은 편안하게 해준다 만약 너가 편안하지 않다면 너는 연습을 통해서 배우지 못할 것이기 떄문입니다.

두번째는 코드를 가지고 노는법을 배우는 것입니다.

실수를 하는 방법, 향상시키는 방법, 반영하는 방법, 그리고 측정하는 방법
이것은 어렵습니다. 
:우리가 올바르게 훈련하는 방법으로 향상시키는 것보다 점수를 내는거라고 배웠습니다.
나는 성공은 단지 무언가를 한 후에 일어난다고 생각합니다.

그래서 나의 당일 도전과제로 :
작은 코드로 45~60분 정도 연스할 수 있는지 확인을 하세요.
당신이 성능을 봐야할 필요는 없습니다.
아마도 너는 구조를 다루거나, 메모리를 사용하거나, 추상화를 할 수 있습니다. 그것은 실험, 측정, 개선 은 결코 중요하지 않습니다.

